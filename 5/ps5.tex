%
% 6.006 problem set 5
%
\documentclass[12pt,twoside]{article}

\input{../macros}

\usepackage{amsmath}
\usepackage{url}
\usepackage{mdwlist}
\usepackage{graphicx}
\usepackage{clrscode3e}
\newcommand{\isnotequal}{\mathrel{\scalebox{0.8}[1]{!}\hspace*{1pt}\scalebox{0.8}[1]{=}}}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{matrix}
\usetikzlibrary{positioning}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{shapes.misc}
\usetikzlibrary{trees}

\setlength{\oddsidemargin}{0pt}
\setlength{\evensidemargin}{0pt}
\setlength{\textwidth}{6.5in}
\setlength{\topmargin}{0in}
\setlength{\textheight}{8.5in}

% Fill these in!
\newcommand{\theproblemsetnum}{5}
\newcommand{\releasedate}{October 24, 2011}
\newcommand{\partaduedate}{Monday, October 31}
\newcommand{\tabUnit}{3ex}
\newcommand{\tabT}{\hspace*{\tabUnit}}

\begin{document}

\handout{Problem Set \theproblemsetnum}{\releasedate}

\newcommand{\solution}[1]{
  \par\medskip
  \textbf{Solution:} #1
}
% \renewcommand{\solution}[1]{ }

\textbf{Both theory and programming questions} are due {\bf \partaduedate} at
{\bf 11:59PM}.
%
Please download the .zip archive for this problem set, and refer to the
\texttt{README.txt} file for instructions on preparing your solutions.

We will provide the solutions to the problem set 10 hours after the problem set
is due. You will have to read the solutions, and write a brief \textbf{grading
explanation} to help your grader understand your write-up. You will need to
submit the grading explanation by \textbf{Thursday, November 3rd, 11:59PM}. Your
grade will be based on both your solutions and the grading explanation.

\medskip

\hrulefill

\begin{problems}

\problem \points{40} \textbf{The Knight's Shield}

The optimized circuit verifier that you developed on your Amdtel internship was
a huge success and got you on a sure track to landing a sweet offer. You also
got transferred to a research group that is working on the \textit{Knight's
Shield (KS)}\footnote{The code name is Amdtel confidential information. Please
refrain from leaking to TechCrunch.}, a high-stakes project to develop a massive
multi-core chip aimed at the exploding secure cloud computing market.

The KS chip packs $16{,}384$ cores in a die that's the same size as a regular
CPU die. However, each core is very small, and can only do arithmetic operations
using 8-bit or 16-bit unsigned integers (see Table~\ref{table:ks-opcodes}).
Encryption algorithms typically use 2,048-bit integers, so the KS chip will ship
with software that supports arithmetic on large integers. Your job is to help
the KS team assess the efficiency of their software.

\begin{table}[htbp]
\centering
\begin{tabular}{|l|c|c|c|l|}
\hline
Operation & R1 size & R2 size & Result size & Result \\
\hline
\texttt{ZERO} & & & 8 / 16 & 0 (zero) \\ 
\hline
\texttt{ONE} & & & 8 / 16 & 1 (one) \\ 
\hline
\texttt{LSB R1} & 16 & & 8 & R1 \% 256 (least significant byte) \\ 
\hline
\texttt{MSB R1} & 16 & & 8 & R1 / 256 (most significant byte) \\ 
\hline
\texttt{WORD R1} & 8 & & 16 & R1 (expanded to 16-bits) \\ 
\hline
\texttt{ADD R1, R2} & 8 / 16 & 8 / 16 & 16 & \texttt{R1} $+$ \texttt{R2} \\ 
\hline
\texttt{SUB R1, R2} & 8 / 16 & 8 / 16 & 16 & \texttt{R1} $-$ \texttt{R2} $\mod
65536$\\
\hline
\texttt{MUL R1, R2} & 8 & 8 & 16 & \texttt{R1} $\cdot$ \texttt{R2} \\ 
\hline
\texttt{DIV R1, R2} & 16 & 8 & 8 & \texttt{R1} $\div$ \texttt{R2} $\mod 256$\\ 
\hline
\texttt{MOD R1, R2} & 16 & 8 & 8 & \texttt{R1} \% \texttt{R2} \\ 
\hline
\texttt{AND R1, R2} & 8 / 16 & 8 / 16 & 8 / 16 & \texttt{R1} \& \texttt{R2}
(bitwise AND) \\
\hline
\texttt{OR R1, R2} & 8 / 16 & 8 / 16 & 8 / 16 & \texttt{R1} $\|$ \texttt{R2}
(bitwise OR) \\
\hline
\texttt{XOR R1, R2} & 8 / 16 & 8 / 16 & 8 / 16 & \texttt{R1} \verb|^|
\texttt{R2} (bitwise XOR) \\
\hline
\end{tabular}
\caption{Arithmetic operations supported by the KS chip. All sizes are in bits.}
\label{table:ks-opcodes}
\end{table}

The KS library supports arbitrarily large base-256 numbers. The base was chosen
such that each digit is a byte, and two digits make up a 16-bit number. Numbers
are stored as a little-endian sequence of bytes (the first byte of a number is
the least significant digit, for example 65534 = 0xFFFE would be stored as
[0xFE, 0xFF]). For the rest of the problem, assume all the input numbers have
$N$ digits.

Consider the following algorithm for computing $A + B$, assuming both inputs
have $N$ digits.

\begin{codebox}
\Procname{$\proc{Add}(A, B, N)$}
\li $C \gets \proc{Zero}(N + 1)$ \Comment{$\proc{Zero}(k)$ creates a $k$-digit
number, with all digits set to 0s.}
\li $\id{carry} \gets 0$
\li \For $i \gets 1$ \To $N$ \label{li:add-for}
\li   \Do
        $\id{digit} \gets \proc{Word}(A[i]) + \proc{Word}(B[i]) +
        \proc{Word}(\id{carry})$
\li     $\id{C[i]} \gets \proc{Lsb}(\id{digit})$
\li     $\id{carry} \gets \proc{Msb}(\id{digit})$
      \End
\li $C[N + 1] \gets \id{carry}$
\li \Return $C$
\end{codebox}

\begin{problemparts}
\problempart \points{1} What is the running time of \proc{Add}?
\begin{enumerate}
  \item $\Theta(1)$
  \item $\Theta(\log N)$
  \item $\Theta(N)$
  \item $\Theta(N^2)$
  \item $\Theta(N^2 \log N)$
  \item $\Theta(N^{\log_2 3})$
  \item $\Theta(N^{\log_2 6})$
  \item $\Theta(N^3)$
\end{enumerate}
\solution {
  $\Theta(N)$, because of the \For loop on line \ref{li:add-for}.
}

\problempart \points{1} What is the size of \proc{Add}'s output?
\begin{enumerate}
  \item $\Theta(1)$
  \item $\Theta(\log N)$
  \item $\Theta(N)$
  \item $\Theta(N^2)$
  \item $\Theta(N^2 \log N)$
  \item $\Theta(N^{\log_2 3})$
  \item $\Theta(N^{\log_2 6})$
  \item $\Theta(N^3)$
\end{enumerate}
\solution {
  $\Theta(N)$, because it returns an $(N + 1)$-digit number.
}

\problempart \points{1} \proc{Add}'s output size suggests an easy lower bound
for the subroutine. Does the running time of \proc{Add} match this lower bound?
\begin{enumerate}
  \item Yes
  \item No
\end{enumerate}
\solution {
  Yes. The running time matches the output size, so the algorithm must be
  optimal.
}
\end{problemparts}

Consider the following brute-force algorithm for computing $A \cdot B$, assuming
both inputs have $N$ digits.

\begin{codebox}
\Procname{$\proc{Multiply}(A, B, N)$}
\li $C \gets \proc{Zero}(2N)$
\li \For $i \gets 1$ \To $N$ \label{li:mul-for1}
\li   \Do
        $\id{carry} \gets 0$
\li     \For $j \gets 1$ \To $N$ \label{li:mul-for2}
\li        \Do
             $\id{digit} \gets A[i] \cdot B[j] + \proc{Word}(C[i + j - 1]) +
                               \proc{Word}(\id{carry})$
\li           $C[i + j - 1] \gets \proc{Lsb}(\id{digit})$
\li           $\id{carry} \gets \proc{Msb}(\id{digit})$
           \End
\li     $\id{C[i + N]} \gets carry$
      \End
\li \Return $C$
\end{codebox}

\begin{problemparts}
\problempart \points{1} What is the running time of \proc{Multiply}?
\begin{enumerate}
  \item $\Theta(1)$
  \item $\Theta(\log N)$
  \item $\Theta(N)$
  \item $\Theta(N^2)$
  \item $\Theta(N^2 \log N)$
  \item $\Theta(N^{\log_2 3})$
  \item $\Theta(N^{\log_2 6})$
  \item $\Theta(N^3)$
\end{enumerate}
\solution {
  $\Theta(N^2)$, because of the nested \For loops on lines \ref{li:mul-for1} and
  \ref{li:mul-for2}.
}

\problempart \points{1} What is the size of \proc{Multiply}'s output?
\begin{enumerate}
  \item $\Theta(1)$
  \item $\Theta(\log N)$
  \item $\Theta(N)$
  \item $\Theta(N^2)$
  \item $\Theta(N^2 \log N)$
  \item $\Theta(N^{\log_2 3})$
  \item $\Theta(N^{\log_2 6})$
  \item $\Theta(N^3)$
\end{enumerate}
\solution {
  $\Theta(N)$, because it returns a $2N$-digit number.
}

\problempart \points{1} \proc{Multiply}'s output size suggests an easy lower
bound for the subroutine. Does the running time of \proc{Multiply} match this
lower bound?
\begin{enumerate}
  \item Yes
  \item No
\end{enumerate}
\solution {
  No. In fact, we do not know a multiplication algorithm that runs in
  $\Theta(N)$ time, and we don't have a proof for a better lower bound than
  $\Theta(N)$ for multiplication.
}
\end{problemparts}

Consider the following brute-force algorithm for computing $A \div B$ and $A
\mod B$, assuming both inputs have $N$ digits. The algorithm uses a procedure
$\proc{Copy}(A, N)$ that creates a copy of an $N$-digit number $A$, using
$\Theta(N)$ time.

\begin{codebox}
\Procname{$\proc{DivMod}(A, B, N)$}
\li $Q \gets \proc{Zero}(N)$ \Comment{quotient}
\li $R \gets \proc{Copy}(A, N)$ \Comment{remainder}
\li $S_0 \gets \proc{Copy}(B, N)$ \Comment{$S_i = B \cdot 2^i$}
\li $i \gets 0$
\li \Repeat \label{li:divmod-repeat}
\li   $i \gets i + 1$
\li   $\id{S_i} \gets \proc{Add}(\id{S_{i - 1}}, \id{S_{i - 1}}, N)$
\li \Until $\id{S_i}[N + 1] > 0$ or $\proc{Cmp}(S_i, A, N) \isequal
            \const{Greater}$
\li \For $j \gets i - 1$ \Downto $0$ \label{li:divmod-for}
\li   \Do
        $Q \gets \proc{Add}(Q, Q, N)$
\li     \If $\proc{Cmp}(R, \id{S_j}, N) \isnotequal \const{Smaller}$
\li     \Then
           $R \gets \proc{Subtract}(R, \id{S_j}, N)$
\li        $Q[0] \gets Q[0] \| 1$ \Comment{Faster version of $Q \gets Q + 1$}
        \End
      \End
\li \Return $(Q, R)$
\end{codebox}

\begin{problemparts}
\problempart \points{1} $\proc{Cmp}(A, B, N)$ returns \const{Greater} if $A >
B$, \const{Equal} if $A = B$, and \const{Smaller} if $A < B$, assuming both $A$
and $B$ are $N$-digit numbers. What is the running time for an optimal
$\proc{Cmp}$ implementation?
\begin{enumerate}
  \item $\Theta(1)$
  \item $\Theta(\log N)$
  \item $\Theta(N)$
  \item $\Theta(N^2)$
  \item $\Theta(N^2 \log N)$
  \item $\Theta(N^{\log_2 3})$
  \item $\Theta(N^{\log_2 6})$
  \item $\Theta(N^3)$
\end{enumerate}
\solution {
  $\Theta(N)$ because, in the worst case, it has to look at every digit in both
  numbers. The following pseudo-code runs in $\Theta(N)$ time.

  \begin{codebox}
  \Procname{$\proc{GreaterEqual}(A, B, N)$}
  \li \For $i \gets 1$ \To $N$
  \li   \Do
          \If $A[i] \neq B[i]$
  \li     \Then
            \If $A[i] > B[i]$
  \li       \Then
              \Return \const{Greater}
  \li       \Else
              \Return \const{Smaller}
            \End
          \End
        \End
  \li \Return \const{Equal}
  \end{codebox}
}

\problempart \points{1} $\proc{Subtract}(A, B, N)$ computes $A - B$, assuming
$A$ and $B$ are $N$-digit numbers. What is the running time for an optimal
$\proc{Subtract}$ implementation?
\begin{enumerate}
  \item $\Theta(1)$
  \item $\Theta(\log N)$
  \item $\Theta(N)$
  \item $\Theta(N^2)$
  \item $\Theta(N^2 \log N)$
  \item $\Theta(N^{\log_2 3})$
  \item $\Theta(N^{\log_2 6})$
  \item $\Theta(N^3)$
\end{enumerate}
\solution {
  $\Theta(N)$. The pseudo-code, run-time analysis, and optimality argument are
  very similar to those for \proc{Add} discussed above.
}

\problempart \points{1} What is the running time of $\proc{DivMod}$?
\begin{enumerate}
  \item $\Theta(1)$
  \item $\Theta(\log N)$
  \item $\Theta(N)$
  \item $\Theta(N^2)$
  \item $\Theta(N^2 \log N)$
  \item $\Theta(N^{\log_2 3})$
  \item $\Theta(N^{\log_2 6})$
  \item $\Theta(N^3)$
\end{enumerate}
\solution {
  $\Theta(N^2)$. The $\kw{Repeat} \ldots \kw{Until}$ loop starting on line
  \ref{li:divmod-repeat} can increase $i$ up to $8N$, which is achieved using
  the extreme values $B = 1$ and $A = 2^{8N} - 1$. So, both the $\kw{Repeat}
  \ldots \kw{Until}$ loop and the \For loop starting on line
  \ref{li:divmod-for} run $\Theta(N)$ times. Each loop makes a constant number
  of calls to \proc{Add}, \proc{Subtract} and \proc{Cmp}, all of which have
  $\Theta(N)$ running time when given $N$-digit long inputs. Therefore, the
  total running time is $\Theta(N) \cdot \Theta(N) = \Theta(N^2)$
}
\end{problemparts}

The KS library does not use the $\proc{DivMod}$ implementation above. Instead,
it uses Newton's method to implement $\proc{Div}(A, B, N)$ which computes the
division quotient $A \div B$, assuming both inputs have $N$ digits. $\proc{Div}$
relies on the subroutines defined above. For example, it uses $\proc{Multiply}$
to perform large-number multiplication and $\proc{Add}$ for large-number
addition. $\proc{Mod}(A, B, N)$ is implemented using the identity $A \mod B = A
- (A \div B) \cdot B$.

\begin{problemparts}

\problempart \points{2} How many times does \proc{Div} call $\proc{Multiply}$?
\begin{enumerate}
  \item $\Theta(1)$
  \item $\Theta(\log N)$
  \item $\Theta(N)$
  \item $\Theta(N^2)$
  \item $\Theta(N^2 \log N)$
  \item $\Theta(N^{\log_2 3})$
  \item $\Theta(N^{\log_2 6})$
  \item $\Theta(N^3)$
\end{enumerate}
\solution {
  $\Theta(\log N)$ times, because it converges quadratically, according to the
  Lecture 12 notes.
}

\problempart \points{2} What is the running time of $\proc{Mod}$?
\begin{enumerate}
  \item $\Theta(1)$
  \item $\Theta(\log N)$
  \item $\Theta(N)$
  \item $\Theta(N^2)$
  \item $\Theta(N^2 \log N)$
  \item $\Theta(N^{\log_2 3})$
  \item $\Theta(N^{\log_2 6})$
  \item $\Theta(N^3)$
\end{enumerate}
\solution {
  $\Theta(N^2)$.
  
  Although $\proc{Multiply}$ is called $\Theta(\log N)$ times in \proc{Div}, the
  operand sizes are different each time, so the total running time for
  \proc{Div} is $\Theta(N^2)$. See the Lecture 12 notes for details.
  
  \proc{Mod} performs an extra multiplication and subtraction, so it takes
  $\Theta(N^2)$ running time in addition to the running time of \proc{Div}. The
  total running time of \proc{Mod} is $\Theta(N^2 + N^2) = \Theta(N^2)$
}
\end{problemparts}

Consider the following brute-force algorithm for computing $B^E \mod M$,
assuming all the input numbers have $N$ digits.

\begin{codebox}
\Procname{$\proc{PowMod}(B, E, M, N)$}
\li $R \gets \proc{One}(N)$ \Comment{result}
\li $X \gets \proc{Copy}(B, N)$ \Comment{multiplier}
\li \For $i \gets 1$ \To $N$ \label{li:exp-for1}
\li   \Do
        $\id{mask} \gets 1$
\li     \For $\id{bit} \gets 1$ \To $8$ \label{li:exp-for2}
\li       \Do
            \If $E[i] \textrm{ \& } \id{mask} \isnotequal 0$
\li         \Then
              $R \gets \proc{Mod}(\proc{Multiply}(R, X, N), M, 2N)$
              \label{li:exp-mulmod1}
            \End
\li         $X \gets \proc{Mod}(\proc{Multiply}(X, X, N), M, 2N)$
            \label{li:exp-mulmod2}
\li         $\id{mask} \gets \proc{Lsb}(\id{mask} \cdot 2)$
          \End
      \End
\li \Return $R$
\end{codebox}

\begin{problemparts}

\problempart \points{2} What is the running time for $\proc{PowMod}$?
\begin{enumerate}
  \item $\Theta(1)$
  \item $\Theta(\log N)$
  \item $\Theta(N)$
  \item $\Theta(N^2)$
  \item $\Theta(N^2 \log N)$
  \item $\Theta(N^{\log_2 3})$
  \item $\Theta(N^{\log_2 6})$
  \item $\Theta(N^3)$
\end{enumerate}
\solution {
  $\Theta(N^3)$. The \For loop on line \ref{li:exp-for1} runs $N$ times, and the
  inner \For loop on line \ref{li:exp-for2} runs $8$ times, so $\proc{Multiply}$
  and $\proc{Mod}$ on lines \ref{li:exp-mulmod1} and \ref{li:exp-mulmod2} are
  called $\Theta(N)$ times. The intermediate multiplication results are always
  reduced modulo $N$, so $R$ and $X$ will always have $\Theta(N)$ digits, which
  means that each $\proc{Mod}$ and $\proc{Multiply}$ call takes $\Theta(N^2)$
  time.
}
\end{problemparts}

Assume the KS library swaps out the brute-force $\proc{Multiply}$ with an
implementation of Karatsuba's algorithm.

\begin{problemparts}
\problempart \points{1} What will the running time for $\proc{Multiply}$ be
after the optimization?
\begin{enumerate}
  \item $\Theta(1)$
  \item $\Theta(\log N)$
  \item $\Theta(N)$
  \item $\Theta(N^2)$
  \item $\Theta(N^2 \log N)$
  \item $\Theta(N^{\log_2 3})$
  \item $\Theta(N^{\log_2 6})$
  \item $\Theta(N^3)$
\end{enumerate}
\solution {
  $\Theta(N^{\log_2 3})$, the running time of Karatsuba's algorithm.
}

\problempart \points{2} What will the running time for $\proc{Mod}$ be after
the optimization?
\begin{enumerate}
  \item $\Theta(1)$
  \item $\Theta(\log N)$
  \item $\Theta(N)$
  \item $\Theta(N^2)$
  \item $\Theta(N^2 \log N)$
  \item $\Theta(N^{\log_2 3})$
  \item $\Theta(N^{\log_2 6})$
  \item $\Theta(N^3)$
\end{enumerate}
\solution {
  $\Theta(N^{\log_2 3})$, for the same reason that $\proc{Mod}$ takes
  $\Theta(N^2)$ time when \proc{Multiply} is implemented using the brute-force
  algorithm.
}

\problempart \points{2} What will the running time for $\proc{PowMod}$ be after
the optimization?
\begin{enumerate}
  \item $\Theta(1)$
  \item $\Theta(\log N)$
  \item $\Theta(N)$
  \item $\Theta(N^2)$
  \item $\Theta(N^2 \log N)$
  \item $\Theta(N^{\log_2 3})$
  \item $\Theta(N^{\log_2 6})$
  \item $\Theta(N^3)$
\end{enumerate}
\solution {
  $\Theta(N^{\log_2 6})$. As argued earlier, $\proc{PowMod}$ calls
  $\proc{Multiply}$ and $\proc{Mod}$ $\Theta(N)$ times with $\Theta(N)$-digit
  long arguments. So the total running time is $\Theta(N) \cdot \Theta(N^{\log_2
  3}) = \Theta(N^{1 + \log_2 3}) = \Theta(N^{\log_2(2 \cdot 3)}) =
  \Theta(N^{\log_2 6})$.
}

\problempart \points{20} Write pseudo-code for $\proc{KthRoot}(A, K, N)$, which
computes $\lfloor \sqrt[K]{A} \rfloor$ using binary search, assuming that $A$
and $K$ are both $N$-digit numbers. The running time for $\proc{KthRoot}(A, K,
N)$ should be $\Theta(N^{2 + \log_2 3})$.

\solution {
  The pseudo-code below implements a binary search for the answer.
  
	\begin{codebox}
	\Procname{$\proc{KthRoot}(A, K, N)$}
  \li $T_0 \gets \proc{One}(N)$ \Comment{$T_i = 2^i$}
  \li $i \gets 0$
  \li \Repeat \label{li:kthroot-repeat}
  \li   $i \gets i + 1$
  \li   $\id{T_i} \gets \proc{Add}(\id{T_{i - 1}}, \id{T_{i - 1}}, N)$
  \li \Until $\id{T_i}[N + 1] > 0$ or $\proc{PowExceeds}(T_i, K, A, N)$
      \label{li:kthroot-until}
  \li $R \gets \proc{Zero}(N)$  \label{li:kthroot-start}
  \li \For $j \gets i - 1$ \Downto $0$  \label{li:kthroot-for}
  \li   \Do
          $R' \gets \proc{Add}(R, T_j)$
  \li     \kw{unless} $\proc{PowExceeds}(R', K, A, N)$
  \li     \Then
             $R \gets R'$
          \End
        \End  \label{li:kthroot-endfor}
  \li \Return $R$
	\end{codebox}

  The pseudo-code uses a helper subroutine $\proc{PowExceeds}(B, E, A, N)$,
  which returns \const{True} iff $B^E > A$, assuming all input numbers are
  $N$-digits long. This solution takes a non-standard approach to implementing
  binary search that is worth taking a look at.
  
  The regular binary search implementation requires a $[\id{low}, \id{high}]$
  range that contains the answer, and uses a guess $g = \lfloor \frac{\id{low} +
  \id{high}}{2} \rfloor$ to narrow the range down to a single number. In
  contrast, this implementation assumes that the answer is non-negative
  $\id{low} = 0$, and does not require a $\id{high}$ upper bound on the answer.
  The \kw{repeat}-\kw{until} loop on lines
  \ref{li:kthroot-repeat}-\ref{li:kthroot-for} computes the upper bound by
  generating powers of $i$ ($\id{T_i}$ is computed to hold $2^i$ inside the
  loop) and stopping when the answer is smaller than $\id{T_i}$, which means
  that we can use $\id{high} = \id{T_i}$ and start the typical binary search
  algorithm on the $[0, \id{T_i}]$ interval. If the answer has $n$ bits, the
  \kw{repeat}-\kw{until} loop runs for $n$ iterations, so having to compute the
  upper bound doesn't change the asymptotic running time of binary search.
  
  Line \ref{li:kthroot-start} initializes $R$, which is going to be returned as
  the result of the binary search. $R$ stands for ``result'', but is actually
  the $\id{low}$ variable in regulary binary search. This is because we are
  asked to compute the floor of the $k^\textrm{th}$ root of $A$. The \kw{for}
  loop on lines \ref{li:kthroot-for}-\ref{li:kthroot-endfor} implements the
  binary search, by successively computing the bits of $R$, from the highest
  bit to the lowest. The variables map to the classical binary search
  implementation as follows: $\id{low}$ is $R$, $\id{high}$ is $R + 2 T_j
  - 1$, and the guess g is $R + T_j$. This holds before the loop because $R =
  0$, and we know that the answer is smaller than $T_i$, so it has to be $\le
  T_i - 1 = 2 T_{i - 1} - 1 = 2 T_j - 1$. Convince yourself that the invariant
  holds throughout the loop, using the fact that $T_i = 2 T_{i - 1}$.
  
  This variant of binary search is interesting because the successive values of
  the guess $g$ only differ by one bit, and it can be implemented solely using
  bitwise operations (shifting, and bitwise OR), whereas the classical binary
  search implementation requires addition. Note that the division by two in
  classical binary search can be implemented using a right shift, so the only
  difference is the need for addition (the $+$ operator).
  
  The \proc{DivMod} pseudo-code given in this problemset follows the same binary
  search strategy for computing the division quotient. Take another look at the
  pseudo-code and convince yourself that this is the case. The first
  result of Googling for \textit{double division} should help visualize the
  divsion algorithm.
  
  \begin{codebox}
  \Procname{$\proc{PowExceeds}(B, E, A, N)$}
  \li $\id{A2} \gets \proc{Zero}(2N)$ \Comment{$A$, zero-extended to $2N$
  digits}
  \li \For $i \gets 1$ \To $N$
  \li   \Do
          $\id{A2}[i] \gets \id{A}[i]$
        \End  
  \li $\id{ones} \gets 0$ \Comment{number of set bits in $E$}
  \li \For $i \gets 1$ \To $N$
  \li   \Do
          $\id{mask} \gets 1$
  \li     \For $\id{bit} \gets 1$ \To $8$ \label{li:exp-for2}
  \li       \Do
              \If $E[i] \textrm{ \& } \id{mask} \isnotequal 0$
  \li         \Then
                $\id{ones} \gets \id{ones} + 1$
              \End
  \li         $\id{mask} \gets \proc{Lsb}(\id{mask} \cdot 2)$
            \End
        \End
  \li $R \gets \proc{One}(N)$ \Comment{result}
  \li $X \gets \proc{Copy}(B, N)$ \Comment{multiplier}
  \li \For $i \gets 1$ \To $N$
  \li   \Do
          $\id{mask} \gets 1$
  \li     \For $\id{bit} \gets 1$ \To $8$
  \li       \Do
              \If $E[i] \textrm{ \& } \id{mask} \isnotequal 0$
  \li         \Then
                $R \gets \proc{Multiply}(R, X, N)$
  \li           \If $\proc{Cmp}(R, A2, 2N) \isequal \const{Greater}$ 
                \label{li:powex-rcmp}
  \li           \Then
                  \Return \const{True}
                \End
  \zi           \Comment{\id{ones} is the number of 1s that haven't yet
                         contributed to $R$}
  \li           $\id{ones} \gets \id{ones} - 1$
  \li           \If $\id{ones} \isequal 0$
  \li           \Then
                  \Return \const{False}  \Comment{$R = B^E \le A$}
                \End
              \End
  \li         $X \gets \proc{Multiply}(X, X, N)$
  \li         \If $\proc{Cmp}(X, A2, 2N) \isequal \const{Greater}$
              \label{li:powex-xcmp}
  \li         \Then
                \Return \const{True}
              \End
  \li         $\id{mask} \gets \proc{Lsb}(\id{mask} \cdot 2)$
            \End
        \End
  \li \Return \const{False}
  \end{codebox}
  
  The \proc{PowExceeds} implementation is similar to that of \proc{PowMod}.
  Instead of calling \proc{Mod}, lines \ref{li:powex-rcmp} and
  \ref{li:powex-xcmp} return \const{False} if the intermediate result is greater
  than $A$, so a modular reduction would occur. If $R$ ever gets greater than
  $A$, we know that the final result will also be greater than $A$, so it's safe
  to return \const{False}. However, $X$ is not always multiplied by $R$, so we
  must take some precaution. This implementation counts the 1 bits in the
  exponent, and returns as soon as $R$ receives the result of the multiplication
  corresponding to the most significant exponent bit that is set to 1. This
  means that when we square $X$, we know the value will eventually be multiplied
  into $R$. Therefore, it is also safe to return \const{False} when an
  intermediate $X$ value exceeds $A$.
  
  Because of all the precautions above, all the intermediate results in
  \proc{PowExceeds} are at most $2N$ digits long, so the subroutine has the same
  running time as \proc{PowMod}, $\Theta(N^{\log_2 6})$.
  
  \proc{NthRoot} performs a binary search, which may use up to $8N$ trials. So
  the total running time of \proc{NthRoot} is $\Theta(N \cdot N^{\log_2 6}) =
  \Theta(N^{1 + \log_2 6}) = \Theta(N^{2 + \log_2 3})$
}
\end{problemparts}

\newpage

\problem \points{18} \textbf{RSA Public-Key Encryption}

The RSA (Rivest-Shamir-Adelman) public-key cryptosystem is a cornerstone of
Internet security. It provides the ``S'' (security) in the HTTPS sessions used
for e-commerce and cloud services that handle private information, such as
e-mail. RSA secures SSH sessions (used to connect to Athena, for example), and
MIT certificates used to log into Stellar. You figure that the KS chip must
perform RSA efficiently, since RSA plays such an important role in cloud
security. This problem will acquaint you with the encryption and decryption
algorithms in RSA.

RSA works as follows. Each user generates two large random primes $p$ and $q$,
and sets his public modulus $m = p \cdot q$. The user then chooses a small
number\footnote{65,537 is a popular choice nowadays} $e$ that is co-prime with
$(p - 1)(q - 1)$, and computes $d = e^{-1} \mod (p - 1)(q - 1)$. The user
announces his public key $(e, m)$ to the world, and keeps $d$ private. In order
to send an encrypted message to our user, another user would encode the message
as a number smaller than $n$, and encrypt it as $c = E(n) = n^e \mod m$. Our
user would decode the message using $D(c) = c^d \mod m$. Assume that keys can be
generated reasonably fast and that $D(E(n)) = n$, for all but a negligible
fraction of values of $n$.

\begin{problemparts}
\problempart \points{1} What is the running time of an implementation of $D(n)$
that uses the KS library in Problem 1, with the optimized version of
\proc{Multiply} (Karatsuba's algorithm), assuming that $n$, $d$ and $m$ are
$N$-byte numbers?
\begin{enumerate}
  \item $\Theta(1)$
  \item $\Theta(\log N)$
  \item $\Theta(N)$
  \item $\Theta(N^2)$
  \item $\Theta(N^2 \log N)$
  \item $\Theta(N^{\log_2 3})$
  \item $\Theta(N^{\log_2 6})$
  \item $\Theta(N^3)$
\end{enumerate}
\solution{
  $\Theta(N^{\log_2 6})$, because $D(n)$ can be computed using a single call to
  $\proc{PowMod}$.
}
\end{problemparts}

You're thinking of using RSA to encrypt important sensitive images, such as
last night's picture of you doing a Keg stand. Formally, a picture has $R \times
C$ pixels ($R$ rows, $C$ columns), and each pixel is represented as 3 bytes that
are RGB color space coordinates\footnote{see
\url{http://en.wikipedia.org/wiki/RGB_color_space}}. The RSA key is $(e, m)$,
where $m$ is an $N$-byte number. An inefficient encryption method would process
each row of pixel data as follows:
\begin{enumerate}
  \item Break the $3C$ bytes of pixel data into groups of $N-1$ bytes
  \item Pad the last group with 0 bytes up to $N-1$ bytes
  \item Encrypt each group of $N-1$ bytes to obtain an $N$-byte output
  \item Concatenate the $N$-byte outputs 
\end{enumerate}

\begin {problemparts}
\problempart \points{1} How many calls to the RSA encryption function $E(n)$
are necessary to encrypt an $R \times C$-pixel image?
\begin{enumerate}
  \item $\Theta(1)$
  \item $\Theta(R C)$
  \item $\Theta(\frac{RC}{N})$
  \item $\Theta(\frac{RN}{C})$
  \item $\Theta(\frac{CN}{R})$
\end{enumerate}
\solution {
  The exact number is $R \lceil \frac{C}{N - 1} \rceil$, which is
  $\Theta(\frac{RC}{N})$.
}

\problempart \points{1} What is the running time for decrypting an $R \times
C$-pixel image that was encrypted using the method above, using the KS library
in Problem 1, with the optimized version of \proc{Multiply} (Karatsuba's
algorithm)?
\begin{enumerate}
  \item $\Theta(N)$
  \item $\Theta(N^2)$
  \item $\Theta(N^2 \log N)$
  \item $\Theta(N^{\log_2 3})$
  \item $\Theta(N^{\log_2 6})$
  \item $\Theta(R C N)$
  \item $\Theta(R C N^2)$
  \item $\Theta(R C N^2 \log N)$
  \item $\Theta(R C N^{\log_2 3})$
  \item $\Theta(R C N^{\log_2 6})$
  \item $\Theta(R N)$
  \item $\Theta(R N^2)$
  \item $\Theta(R N^2 \log N)$
  \item $\Theta(R N^{\log_2 3})$
  \item $\Theta(R N^{\log_2 6})$
\end{enumerate}
\solution {
  $\Theta(RCN^{\log_2 3})$

  The running time of one decryption operation is $\Theta(N^{\log_2 6})$, and
  decrypting the entire image requires $\Theta(\frac{RC}{N})$ operations, so the
  total running time is $\Theta(\frac{RC \cdot N^{\log_2 6}}{N}) =
  \Theta(\frac{RC \cdot N^{1 + \log_2 3}}{N}) = \Theta(RCN^{\log_2 3})$.
}

\problempart \points{5} A fixed point under RSA is a number $n$ such that $E(n)
\equiv n \mod m$, so RSA does not encrypt the number at all. Which of the
following numbers are fixed points under RSA? (True / False)
\begin{enumerate}
  \item $0$
  \item $1$
  \item $2$
  \item $3$
  \item $m - 2$
  \item $m - 1$
\end{enumerate}
\solution {
  $0$, $1$, and $m - 1$ are fixed points.
  
  $0^e = 0$ and $1^e = 1$ for any value of $e > 0$. $m - 1 \equiv -1 \mod m$,
  and we know that $(-1)^{e} = -1$ if $e$ is odd. The other choices can be
  eliminated by choosing $e = 3$ and $m = 35 = 5 \cdot 7$. $2^3 \equiv 8 \mod
  35$, $3^3 \equiv 27 \mod 35$, and $(35 - 2)^3 \equiv (-2)^3 \equiv -8 \equiv
  27 \mod 35$.
}
  
\problempart \points{5} What other weaknesses does the RSA algorithm have?
(True / False)
\begin{enumerate}
  \item $E(-n) \equiv -E(n) \mod m$
  \item $E(n_1) + E(n_2) \equiv E(n_1 + n_2) \mod m$
  \item $E(n_1) - E(n_2) \equiv E(n_1 - n_2) \mod m$
  \item $E(n_1) \cdot E(n_2) \equiv E(n_1 \cdot n_2) \mod m$
  \item $E(n_1)^{n_2} \equiv E(n_1 ^ {n_2}) \mod m$
\end{enumerate}
\solution {
  $E(-n) \equiv -E(n) \mod m$, $E(n_1) \cdot E(n_2) \equiv E(n_1 \cdot n_2)
  \mod m$, and $E(n_1)^{n_2} \equiv E(n_1 ^ {n_2}) \mod m$

  The positive answers can be proven by using algebra on the definition of
  $E(n)$. $E(n_1 \cdot n_2) \equiv (n_1\cdot n_2)^e \equiv (n_1^e) \cdot (n_2^e)
  \equiv E(n_1) \cdot E(n_2) \mod m$. Also, $E(-n) \equiv (-n)^e \equiv -(n^e)$,
  because $e$ is odd. Last, $E(n_1 ^ {n_2}) \equiv (n_1 ^ {n_2}) ^ e \equiv
  n_1 ^ {(n_2 \cdot e)} \equiv (n_1 ^ e) ^ (n_2) \equiv E(n_1) ^ {n_2}$.
  
  The negative answers can be proven by counter-example. $E(1) + E(1) = 2 \neq
  8 = 2^3 = E(1 + 1)$ for $n_1 = n_2 = 1$, $e = 3$ and $m = 35$. Similarly,
  $E(2) - E(1) = 2^3 - 1 = 7 \neq 1 = E(2 - 1)$.
}

\problempart \points{5} Amdtel plans to use RSA encryption to secretly tell
Gopple when its latest smartphone CPU is ready to ship. Amdtel will send one
message every day to Gopple, using Gopple's public key ($e_G$, $m_G$). The
message will be \const{No} (the number 20079 when using ASCII), until the day
the CPU is ready, then the message will change to \const{Yes} (the number
5858675 when using ASCII). You pointed out to your manager that this security
scheme is broken, because an attacker could look at the encrypted messages, and
know that the CPU is ready when the daily encrypted message changes. This is a
problem of deterministic encryption. If $E(20079)$ always takes the same value,
an attacker can distinguish $E(20079)$ from $E(5858675)$. How can the problem of
deterministic encryption be fixed? (True / False)

\begin{enumerate}
  \item Append the same long number (the equivalent of a string such as
  'XXXPADDINGXXX') to each message, so the messages are bigger.
  \item Append a random number to each message. All random numbers will have the
  same size, so the receiver can recognize and discard them.
  \item Use a different encryption key to encrypt each message, and use Gopple's
  public exponent and modulus to encrypt the decryption key for each message.
  \item Use an uncommon encoding, such as UTF-7, so that the attacker will not
  know the contents of the original messages.
  \item Share a ``secret'' key with Gopple, so that the attacker can't use the
  knowledge on Gopple's public exponent and modulus.
\end{enumerate}
\solution {
  Appending a random number and using per-message encryption keys both work,
  because they make the encryption output non-deterministic. All the other
  proposals don't change the fact that a message will always look the same after
  encryption, which is what the attacker uses to detect the change from
  \const{No} to \const{Yes}.
}
\end{problemparts}

\newpage

\problem \points{42} \textbf{Image Decryption}

Your manager wants to show off the power of the Knight's Shield chip by
decrypting a live video stream directly using the RSA public-key crypto-system.
RSA is quite resource-intensive, so most systems only use it to encrypt the key
of a faster algorithm. Decrypting live video would be an impressive technical
feat!

Unfortunately, the performance of the KS chip on RSA decryption doesn't come
even close to what's needed for streaming video. The hardware engineers said the
chip definitely has enough computing power, and blamed the problem on the
RSA implementation. Your new manager has heard about your algorithmic chops, and
has high hopes that you'll get the project back on track. The software engineers
suggested that you benchmark the software using images because, after all, video
is just a sequence of frames.

The code is in the \texttt{rsa} directory in the zip file for this problem set.

\begin{problemparts}
\problempart \points{2} Run the code under the python profiler with the command
below, and identify the method inside \texttt{bignum.py} that is most suitable
for optimization. Look at the methods that take up the most CPU time, and
choose the first method whose running time isn't proportional to the size of its
output.

\texttt{python -m cProfile -s time rsa.py < tests/1verdict\_32.in}

\textit{Warning:} the command above can take 1-10 minutes to complete, and
bring the CPU usage to 100\% on one of your cores. Plan accordingly. If
you have installed PyPy successfully, you should replace \texttt{python} with
\texttt{pypy} in the command above for a 2-10x speed improvement. 

What is the name of the method with the highest CPU usage?
\solution {
  \texttt{fast\_mul}
  
  The first line in the profiler output points to \texttt{\_\_add\_\_}, but
  the addition algorithm is optimal ($O(N)$ running time, $O(N)$ output size).
  The next line points to \texttt{fast\_mul}.
  
  PyPy's output may have \texttt{\_\_init\_\_} and \texttt{normalize} above
  \texttt{fast\_mul}. These methods are also implemented using optimal
  algorithms, so they are not good answers for the question.
}

\problempart \points{1} How many times is the method called?
\solution {
  The second line in the profiler output indicates that \texttt{fast\_mul} is
  called 93496 times.
}

\problempart \points{1} The troublesome method is implementing a familiar
arithmetic operation. What is the tightest asymptotic bound for the worst-case
running time of the method that contains the bottleneck? Express your answer in
terms of $N$, the number of digits in the input numbers.
\begin{enumerate}
  \item $\Theta(N)$.
  \item $\Theta(N \log n)$
  \item $\Theta(N \log^2 n)$
  \item $\Theta(N^{\log_{2} 3})$
  \item $\Theta(N^2)$
  \item $\Theta(N^{\log_{2} 7})$
  \item $\Theta(N^3)$
\end{enumerate}
\solution {
  \texttt{\_\_mul\_\_} implements multiplication using Karatsuba's algorithm.
  The running time for this algorithm is $\Theta(N^{\log_{2} 3})$.
}

\problempart \points{1} What is the tightest asymptotic bound for the worst-case
running time of division? Express your answer in terms of $N$, the number of
digits in the input numbers.
\begin{enumerate}
  \item $\Theta(N)$.
  \item $\Theta(N \log n)$
  \item $\Theta(N \log^2 n)$
  \item $\Theta(N^{\log_{2} 3})$
  \item $\Theta(N^2)$
  \item $\Theta(N^{\log_{2} 7})$
  \item $\Theta(N^3)$
\end{enumerate}
\solution {
  \texttt{\_\_div\_\_} uses \texttt{\_\_divmod\_\_}, which implements division
  using Newton's algorithm. The asymptotic running time is the same as the
  running time of the underlying multiplication algorithm which is
  $\Theta(N^{\log_{2} 3})$ in this case.
}
\end{problemparts}

We have implemented a visualizer for your image decryption output, to help you
debug your code. The visualizer will also come in handy for answering the
question below. To use the visualizer, first produce a trace.

\texttt{TRACE=jsonp python rsa.py < tests/1verdict\_32.in > trace.jsonp}

On Windows, use the following command instead.

\texttt{rsa\_jsonp.bat < tests/1verdict\_32.in > trace.jsonp}

Then use Google Chrome to open
\texttt{visualizer/bin/visualizer.html}

\begin{problemparts}
\problempart \points{6} The test cases that we supply highlight the problems of
RSA that we discussed above. Which of the following is true? (True / False)
\begin{enumerate}
  \item Test \texttt{1verdict\_32} shows that RSA has fixed points.
  \item Test \texttt{1verdict\_32} shows that RSA is deterministic.
  \item Test \texttt{2logo\_32} shows that RSA has fixed points.
  \item Test \texttt{2logo\_32} shows that RSA is deterministic.
  \item Test \texttt{5future\_1024} shows that RSA has fixed points.
  \item Test \texttt{5future\_1024} shows that RSA is deterministic.
\end{enumerate}
\solution {
  Test \texttt{1verdict\_32} shows both fixed points (the black eyes and mouth
  remain black in the encrypted image) and determinism (the rest of the face
  looks the same, so we can guess it's the same color). In
  \texttt{4verdict\_512}, the bigger key size hides the fixed points.

  Test \texttt{2logo\_32} shows determinism. Although the colors are off, the
  encrypted image clearly represents the MIT logo.

  Test \texttt{5future\_1024} does not shows fixed points or deterministic
  encryption, because of the noise in the source image. The encrypted image
  looks like white noise.
}

\problempart \points{1} Read the code in \texttt{rsa.py}. Given a decrypted
image of $R \times C$ pixels ($R$ rows, $C$ columns), where all the pixels
are white (all the image data bytes are 255), how many times will
\texttt{powmod} be called during the decryption operation in
\texttt{decrypt\_image}?
\begin{enumerate}
  \item $\Theta(1)$
  \item $\Theta(R C)$
  \item $\Theta(\frac{RC}{N})$
  \item $\Theta(\frac{RN}{C})$
  \item $\Theta(\frac{CN}{R})$
\end{enumerate}
\solution {
  $\Theta(1)$. \texttt{RsaKey} uses a dictionary to cache decryption results, so
  \texttt{powmod} is called at most twice: once for a ``chunk'' of pixels inside
  a row, and once for a ``chunk'' of pixels at the end of the row, which
  would be padded with 0s.
}

\problempart \points{30} The multiplication and division operations in
\texttt{big\_num.py} are implemented using asymptotically efficient algorithms
that we have discussed in class. However, the sizes of the numbers involved in
RSA for typical key sizes aren't suitable for complex algorithms with high
constant factors. Add new methods to \texttt{BigNum} implementing multiplication
and division using straight-forward algorithms with low constant factors, and
modify the main multiplication and division methods to use the simple algorithms
if at least one of the inputs has 64 digits (bytes) or less. Please note that
you are not allowed to import any additional Python libraries and our test will
check this.
\end{problemparts}

The KS software testing team has put together a few tests to help you check your
code's correctness and speed. \texttt{big\_num\_test.py} contains unit tests
with small inputs for all \texttt{BigNum} public methods.
\texttt{rsa\_test.py} runs the image decryption code on the test cases in the
\texttt{tests/} directory.

You can use the following command to run all the image decryption tests.

\texttt{python rsa\_test.py}

To work on a single test case, run the simulator on the test case with the
following command.

\texttt{python rsa.py < tests/1verdict\_32.in > out}

Then compare your output with the correct output for the test case.

\texttt{diff out tests/1verdict\_32.gold}

For Windows, use \texttt{fc} to compare files.

\texttt{fc out tests/1verdict\_32.gold}

While debugging your code, you should open a new Terminal window (Command Prompt
in Windows), and set the \texttt{KS\_DEBUG} environment variable (\texttt{export
KS\_DEBUG=true}; on Windows, use \texttt{set KS\_DEBUG=true}) to use a slower
version of our code that has more consistency checks.

When your code passes all tests, and runs reasonably fast (the tests should
complete in less than 90 seconds on any reasonably recent computer using PyPy,
or less than 600 seconds when using CPython), upload your modified
\texttt{big\_num.py} to the course submission site. Our automated grading code
will use our versions of \texttt{test\_rsa.py}, \texttt{rsa.py} and
\texttt{ks\_primitives.py} / \texttt{ks\_primitives\_unchecked.py}, so please do
not modify these files.

\solution {
  The solution archive on the course Web site contains the staff's solution and
  secret test cases.
}

\end{problems}
\end{document}
